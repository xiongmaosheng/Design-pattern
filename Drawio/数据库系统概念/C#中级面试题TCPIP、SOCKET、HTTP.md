# C#中级面试题TCP/IP、SOCKET、HTTP

#### 1. 网络各个协议：TCP/IP、SOCKET、HTTP

答：网络七层由下往上分为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。
http协议 对应 应用层
tcp协议 对应 传输层
ip 协议 对应 网络层
TCP/IP 是传输层协议，主要解决数据如何在网络中传输，而http是应用层协议，主要解决如何包装数据
Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议

#### 2.TCP连接

答：Socket是对TCP/IP协议的封装,要想明白Socket连接，先要明白TCP连接。
建立起一个TCP连接需要经过“三次握手”：

- 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
- 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
- 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连 接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”

#### 3. TCP 连接的建立步骤

答：典型的 TCP 客户端要经过下面三步操作：

- 创建一个 Socket 实例：构造函数向指定的远程主机和端口建立一个 TCP 连接
- 通过套接字的 I/O 流与服务端通信
- 使用 Socket 类的 close 方法关闭连接

服务端的工作是建立一个通信终端，并被动地等待客户端的连接。典型的 TCP 服务端执行如下两步操作：

- 创建一个 ServerSocket 实例并指定本地端口，用来监听客户端在该端口发送的 TCP 连接请求
- 重复执行：
  - 调用 ServerSocket 的 accept（）方法以获取客户端连接，并通过其返回值创建一个 Socket 实例；
  - 为返回的 Socket 实例开启新的线程，并使用返回的 Socket 实例的 I/O 流与客户端通信； 通信完成后，使用 Socket 类的 close（）方法关闭该客户端的套接字连接

#### 4.HTTP连接

答：HTTP协议即超文本传送协议(HypertextTransfer Protocol )，是Web联网的基础，HTTP协议是建立在TCP协议之上的一种应用。
HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。

由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的 做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客 户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。

#### 5. HTTP之请求消息Request

答:客户端发送一个HTTP请求到服务器的请求消息包括以下格式:
**请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。**

image.png


请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。Get请求例子，使用Charles抓取的request：

```
GET /562f25980001b1b106000338.jpg HTTP/1.1
Host    img.mukewang.com
User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36
Accept    image/webp,image/*,*/*;q=0.8
Referer    http://www.imooc.com/
Accept-Encoding    gzip, deflate, sdch
Accept-Language    zh-CN,zh;q=0.8
```

- 第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
  GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。
- 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息
  从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等
- 第三部分：空行，请求头部后面的空行是必须的
  即使第四部分的请求数据为空，也必须有空行。
- 第四部分：请求数据也叫主体，可以添加任意的其他数据。
  这个例子的请求数据为空。

POST请求例子，使用Charles抓取的request：

```
POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
```

- 第一部分：请求行，第一行明了是post请求，以及http1.1版本。
- 第二部分：请求头部，第二行至第六行。
- 第三部分：空行，第七行的空行。
- 第四部分：请求数据，第八行。

#### 6.HTTP之响应消息Response

答:一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。
**HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。**

```
例子
HTTP/1.1 200 OK
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8

<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
```

- 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。
  第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）
- 第二部分：消息报头，用来说明客户端要使用的一些附加信息
  第二行和第三行为消息报头，
  Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8
- 第三部分：空行，消息报头后面的空行是必须的
- 第四部分：响应正文，服务器返回给客户端的文本信息。
  空行后面的html部分为响应正文。

#### 7.简述同步IO和异步IO的区别

答:

- 同步：
  所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。
  例如普通B/S模式（同步）：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事
- 异步：
  异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。
  例如 ajax请求（异步）: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕
- 阻塞：
  阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。
  有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回,它还会抢占cpu去执行其他逻辑，也会主动检测io是否准备好。
- 非阻塞：
  非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

再简单点理解就是：

1. 同步，就是我调用一个功能，该功能没有结束前，我死等结果。
2. 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）。
3. 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。
4. 非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者
   同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞
   阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回
   综上可知，同步和异步,阻塞和非阻塞,有些混用,其实它们完全不是一回事,而且它们修饰的对象也不相同。


 